# Declare three varibales that we can use everywhere a float is expected.
float red(0.5)
float green(0.5)
float blue(0.5)

# Declare a few new materials. Each of them includes a BRDF and a pigment.
material sky_material(
	diffuse(uniform(<0.8, 0.1, 1.>)),	# A diffuse BRDF will reflect rays in random directions.
	uniform(<0.6, 0.6, 0.8>)		# The sky is a light source, so we assign a non-black pigment to it.
)

material ground_material(
	diffuse(checkered(<0.3, 0.5, 0.1>,	# The ground is checkered: two colors are alternated, and the unit square is divided in 4.
		<0.1, 0.2, 0.5>, 4)),		# As you have surely noticed, colors are defined using the <red, green, blue> syntax.
	uniform(<0, 0, 0>)			# No light from the ground...
)

material box_material(
	dielectric(uniform(<red, green, blue>), 0.1, 1.5),	# The box has a dielectric material, with roughness 0.1 and refracion index 1.5. Like an ice cube.
	uniform(<0, 0, 0>)
)

material sphere_material(
	diffuse(image("../textures/marble_20.pfm", <0.8, 0.3, 0.4>)),	# The sphere uses a texture as the pigment for its BRDF. You can use any pmf you like.
	uniform(<0, 0, 0>)
)

# Define a few shapes

# Each shape has a material as its first argument, and a transformation as its last argument.
# Depending on the shape, there can be middle parameters: for example, the box takes the minimum and maximum vertices.
box(box_material, [-0.5, -0.5, -1], [0.5, 0.5, 0], rotation_z(45) * translation([0, -1, 0]))

# The unit sphere, to which some transformations are applied.
# You can combine transformations with *. They are applied from right to left.
sphere(sphere_material, translation([0, 0, 0.5]) * scaling([0.5, 0.5, 0.5]) * translation([0, -0.9, 0]))

# Let's now define the ground with a plane.
# The language is flexible enough to permit spaces before "("
plane (ground_material, translation([0, 0, -1]))

# Finally, the sky is a big sphere.
sphere(sky_material, scaling([7.5, 7.5, 7.5]))

# Without a camera, there is nothing to see.
# You can set the type of camera, the tranformation to apply and the distance from the screen.
# The aspect ratio is calculated from the width and height, and can be overwritten with a parameter to pass to the render action.
camera(perspective, translation([-1, 0, 0]), 1.0)
